Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук
Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: "Програмна система для збору інформації про діяльність школярів та працівників навчального закладу"

Студент гр. ПЗПІ-21-3  	__________________ Фомичов А.С.
(підпис)

Керівник роботи 			___________________ доц. Лещинський В.О.
(підпис)
    Роботу захищено «__»_________2024 р.
    з оцінкою _________________________

Комісія: 				___________________ доц. Лещинський В.О.
(підпис)	
___________________ доц. Лещинська І.О.
(підпис)
___________________ ст.викл. Сокорчук І.П.
(підпис)

Харків
2024 р.
Харківський національний університет радіоелектроніки 


Факультет комп’ютерних наук      .Кафедра програмної інженерії              .
Спеціальність 121-Інженерія програмного забезпечення                              .
Курс 3              Семестр _________________6_________________________ 
Дисципліна Архітектура програмного забезпечення_______________ 

ЗАВДАННЯ 
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ 
                                        Фомичову Артем Сергійовичу                                            
1. Тема проєкту: «Програмна система для збору інформації про діяльність школярів та працівників навчального закладу» 
2. Термін узгодження завдання з лабораторних робіт «19» лютого  2024 р. 
3. Термін здачі завдання з лабораторних робіт «25»  травня   2024 р. 
4. Вихідні дані до проєкту: В програмній системі передбачити: додавання та редагування користувача, школи, кімнати, відвідування, формування статистики відвідування, функціонал пропозиції-відповіді                                       
5. Зміст звітів з лабораторних робіт (перелік питань, що належить розробити): вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки                                                                                                              
6. Перелік графічного матеріалу (діаграми, рисунки, інтерфейси): Deployment Diagram, Use Case Diagram, ER-модель даних, Package Diagram, Interaction Overview Diagram, Activity Diagram, інтерфейс головної сторінки                          

КАЛЕНДАРНИЙ ПЛАН


№	Основні етапи виконання проєкту в рамках лабораторних робіт	Термін виконання етапів	Примітка
1	Функціональна специфікація
програмного проекту	26.02.2024	виконано
2	Проектування програмного
проекту	04.03.2024	виконано
3	Кодування програмного проекту	20.05.2024	виконано
4	Оформлення пояснювальної
записки	05.06.2024	виконано
5	Захист курсової роботи	17.06.2024	виконано

Дата видачі теми проєкту «19» лютого 2024 р. 

Керівник курсової роботи 				__________ доц. Лещинська І.О.

Завдання прийняв до виконання 
ст. гр. ПЗПІ-21-3 						_____________	 Фомичов А.С.


РЕФЕРАТ


Пояснювальна записка до курсової роботи: 52 с., 27 рис., додатки, джерела. 
БІОМЕТРИЧНІ ДАНІ, НАВЧАЛЬНИЙ ЗАКЛАД, ПРОГРАМНЕ ЗАБЕЗПЕЧЕННЯ, СКАНЕР, ВІДВІДУВАННЯ
Об’єктом дослідження є автоматизація збору інформації про діяльність школярів та працівників навчального закладу за допомогою біометричних технологій. Відкритими питаннями наразі є створення надійної та зручної системи для моніторингу присутності та здоров'я учасників освітнього процесу.
Метою курсової роботи є розробка програмної системи, яка забезпечить автоматизований збір інформації про присутність та активність школярів і працівників навчального закладу з використанням сканерів відбитків пальців і температури. Ця система дозволить підвищити рівень безпеки та ефективність моніторингу стану здоров'я.
Методи розробки базуються на використанні середи розробки Microsoft Visual Studio Code 2022, Microsoft Visual Studio 2022 та симулятора Wokwi, за допомогою технологій ASP.NET, Arduino, Angular та .NET MAUI, та з використанням СУБД SSMS. 
У результаті роботи здійснено програмну реалізацію системи для збору інформації про діяльність школярів та працівників навчального закладу з використанням сканерів відбитку пальця та температури. Програмна система складається з веб-додатку, сервера, мобільного додатку та смарт-пристрою.

ЗМІСТ


Вступ	7
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ.........................................…..………	8
   1.1 Загальний огляд предметної області...................................................	8
   1.2 Аналіз існуючих аналогів.………………………………..…….….....	9
2 ПОСТАНОВКА ЗАВДАННЯ.....................................................................	10
   2.1 Затвердження бачення програмної системи........................................	10
   2.2 Користувачі системи та потреби цільового ринку..............................	10
   2.3 Припущення та залежності...................................................................	11
   2.4 Основний функціонал та сценарії використання системи.................	12
   2.5 Ризики програмної системи..................................................................	13
   2.6 Обмеження та винятки .........................................................................	13
   2.7 Вимоги до програмної системи та стек технологій............................	14
3 АРХІТЕКТУРА Й ПРОЄКТУВАННЯ СИСТЕМИ...................................	16
   3.1 UML-моделювання................................................................................	16
   3.2 Проєктування бази даних......................................................................	16
   3.3 Загальна архітектура програмної системи...........................................	17
   3.4 Архітектура серверної частини............................................................	17
   3.5 Архітектура ІоТ......................................................................................	18
4 ОПИС ПРОГРАМНИХ РІШЕНЬ...............................................................	19
   4.1 Програмні рішення серверного застосунку.........................................	19
      4.1.1 Робота з базою даних.......................................................................	19
      4.1.2 Автентифікація................................................................................	19
      4.1.3 Специфікація REST API..................................................................	20
      4.1.4 Валідація на сервері.........................................................................	20
      4.1.5 Локалізація.......................................................................................	21
      4.1.6 Використання механізму Dependency Injection.............................	21
      4.1.7 Забезпечення безпеки даних...........................................................	22
   4.2 Програмні рішення ІоТ-застосунку......................................................	22
      4.2.1 Формування запитів.........................................................................	22
      4.2.2 Локалізація.......................................................................................	23
      4.2.3 Обчислення статистики...................................................................	23
      4.2.4 Адміністрування пристрою............................................................	24
ВИСНОВКИ....................................................................................................	25
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ..............................................................	26
ДОДАТОК А UML-діаграма прецедентів...................................................	27
ДОДАТОК Б UML-діаграма розгортання....................................................	29
ДОДАТОК В ER-діаграма.............................................................................	30
ДОДАТОК Г UML-діаграма пакетів............................................................	31
ДОДАТОК Д Код GenericRepository............................................................	32
ДОДАТОК Е Код AccountService.................................................................	35
ДОДАТОК Ж Специфікація REST API.......................................................	42
ДОДАТОК К Код IoT-застосунку................................................................	45


ВСТУП


Останнім часом, більшість навчальних закладів перейшла на дистанційний формат навчання, але згодом всі школи будуть працювати як це було до 2020 року. Діти так само будуть відвідувати заклади, формувати гурти та займатися своїми захопленнями. Для цього потрібно, щоб школа була готова до нових ідей та нового часу, потрібно щоб дітям та працівникам було зручно займатися своєю справою і щоб вони робили це із задоволенням, потрібно щоб була комунікація між школярами та викладачами та не було потреби шукати один одного по всьому навчальному закладі. 
Метою виконання курсової роботи є проектування та розробка програмного проекту з використанням основних принципів проектування архітектури програмного забезпечення, архітектурних шаблонів та стилів, методики побудови архітектури програмного забезпечення, проектування шару представлення, бізнес-шару, шару доступу до даних, шару сервісів.
В результаті виконання курсової роботи ми отримуємо проєкт для комунікації між відвідувачами закладів. Головна ідея полягає в створенні зручної та надійної системи, яка буде містити інформацію про відвідувачів (дату та час відвідування школи та температуру), надає змогу комунікації між користувачами системи, бронювання загальнодоступних кімнат, залів та класів для зайнять. Наш продукт дасть можливість користувачам здійснювати більшого функціоналу в декілька рухів у мобільному додатку.
Для досягнення мети виконано такі завдання: вивчення можливих варіантів архітектур програмного забезпечення, патернів проєктування [3], принципів «чистого» коду [3], аналіз предметної області, галузі застосування та впровадження програмного рішення; проєктування системи та бази даних; програмну реалізацію задуму з дотриманням принципів «чистого» коду [3, 4] та «чистої» архітектури.

1	АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Загальний огляд предметної області


Останнім часом навчальні заклади адаптувалися до дистанційного формату навчання через пандемію COVID-19 та повномасштабне вторгнення, але з поверненням до традиційного навчання виникає необхідність в удосконаленні управління закладами освіти. Зокрема, це стосується забезпечення зручності та ефективності комунікації між учнями, викладачами та адміністрацією школи.
Більшість з закладів не мають жодних систем для відстежування відвідування закладів, систем комунікації та інформування стосовно зайнятості залів, класів тощо. Отже, ми можемо сформувати наступні аспекти предметної області:
	Відвідування навчальних закладів,
	Комунікація між учасниками освітнього процесу,
	Організація позакласних заходів та занять. 
Це сприятиме підвищенню ефективності управління навчальними закладами та забезпечить комфортні умови для навчання та взаємодії учнів та викладачів.
Система має надавати послуги зі збору інформації про відвідувачів закладу та формування статистики відвідування, комунікації між школярами та працівниками закладу, створення запитів та інформування.
Система має ставити на меті вдосканалити систему комунікації в навчальних закладах та зробити систему навчання більш зручною для вчителів та учнів. Також система допоможе моніторити стан здоров’я, що може посприяти до врегулювання навантаження на учнів
Систему розроблено для всіх закладів освіти, які бажають надавати учням та працівникам можливість розвиватися та демонструвати свої амбіції. 


1.2	Аналіз аналогів системи


На ринку вже існують систему для моніторингу відвідування закладів. Прикладом може виступити продукція компанії Ajax. Але їх продукція призначена більше для безпеки, а саме: захист від вторгнення, відеоспостереження, виявлення пожежі, запобігання потопу тощо [1]. 
Конкуретною перевагою нашої системи є специфікація на навчальних закладах:
	Формування статистики здоровья користувачів, 
	Контроль відвідування занять,
	Зручна комунікація між викладачами та учнями,
	Можливість забронювати приміщення для додаткових занять,
	Можливість пропонування нових ідей та подій,
	Моніторинг класів та залів.
Керівництво школи має можливість замовити встановлення відповідних датчиків для підключення своєї школи до системи та самостійно налаштувати облікові записи учнів, вчителів та решти працівників. 
Продукт орієнтований на український ринок, але системою підтримується локалізація часу та мови інтерфейсу для учнів, у котрих рідна мова не українська. Система використовує міжнародний формат часу, що дає моливість в подальшому розглядати її як більш масштабною. 
Ми плануємо забезпечити безкоштовний доступ користувачам до нашої системи. Наша прибуткова модель полягає у продажі системи за собівартістю, фінансування благодійними організаціями та державою, проведення реклами погодженою з керівництвом, так як основна мета проекту – це забезпечити зручне навчання.


2	ПОСТАНОВКА ЗАВДАННЯ
2.1	Затвердження бачення програмної системи.


Інформаційна система EduCheck надаватиме послуги моніторингу відвідування закладу та температу користувачів, а також сервісом для розвитку школи, учнів та педагогічного складу.  
 Відвідувачі закладу під час прибуття до школи сканують свій палець за допомогою «розумного» сенсору, який фіксує температуру тіла, відбиток пальцю та віправляє запит до серверу, де в подальшому проходить процедура ідентифікації та створення відповідного запису. У разі, якщо користувач не бажає або не має можливості відсканувати палець, то охоронець або інший працівник може за допомогою додатку додати запис до системи. Таким чином кожен користувач може переглядати власну історія та статистику відвідувань. Вчителі та директорм можуть переглядати, хто з учнів був присутній на заняттях, а хто ні. 
Директор отримає доступ до управління користувачами та їхніми можливостями в системі, статистику щодо загального відвідування, редагувати пропозиції та надавати на них відповіді. 


2.2	Користувачі системи та потреби цільового ринку
Користуватися системою будуть школярі та працівники закладів. Відповідно для кожного з них буде окремий функціонал. Можна виділити наступні потреби школярів: 
	Можливість забронювати приміщення для додаткових занять; 
	Зручна комунікація з викладачами; 
	Можливість пропонування нових ідей та подій; 
	Інформування стосовно змін. 
В той час як для викладачів та директора закладу наступними потребами будуть: 
	Контроль відвідування занять, 
	Перегляд зайнятості класів, залів тощо,
	Слідкування за станом здоров’я учнів, 
	Комунікація зі школярами, 
	Інформування учнів стосовно змін. 
Наш продукт відрізняється від інших аналогів завдяки зручному мобільному додатку, надійній системі датчиків, системою безпеки та можливості відстежування статистики використання. 


2.3	Припущення та залежності


Важливим кроком є сформувати припущення та залежності нашого проєкту на початку проєктування та реалізації. Наступними припущення було, що:
	Існує значний попит на покращення умов навчання у школах. 
	Технічна реалізація системи буде успішною та надійною. 
	Система «EduCheck» зможе зацікавити держапарат та заклади освіти. 
	Користувачі мають доступ до Інтернету для взаємодії з системою «EduCheck» . 
	Користувач вміє користуватися мобільними пристроями, завантажувати додатки. 
Також проєкт залежить від багатьох факторів. Основні з яких наступні: 
	Проект залежить від успішної реалізації технологій для роботи сканера відбитку пальця та розробки програмного забезпечення. 
	Успішний розвиток проекту може залежати від укладення партнерських угод з держапаратом та благодійними організаціями, закладами освіти. 
	Залежність від наявності технічної підтримки для вирішення можливих проблем та відмов у роботі системи. 
	Залежність від наявності необхідних ресурсів, таких як сервери та обладнання для роботи системи. 
	В закладах освіти користувачі мають доступ до Інтернету.


2.4	Основний функціонал та сценарії використання системи


Провівши аналіз потреб користувачів системи, можна визначити головні функції, які повині бути реалізованими для першої версії:
	Сканування часу прибуття до закладу та температури за допомогою сканеру відбитку пальця. 
	Створення оголошень стосовно змін. 
	Створення та обробка запитів на бронювання приміщення або проведення подій. 
	Перегляд та редагування розкладу занять. 
	Перегляд статистики зайнятості школярів. 
	Надання системою безпеки персональних даних. 
	Можливість обрати українську або англійську локалізацію інтерфейсу програмної системи.


2.5	Ризики програмної системи


При розробці проєкту потрібно мати на увазі про можливі ризики. Наприклад, можливі технічні проблеми або збої в роботі датчиків. Для уникнення даної проблеми потрібно проводи ретельне тестування та вдосконалення датчиків виміру температури та сканерів відбитку пальців перед впровадженням
До ризів також відноситься конкуренція на ринку з іншими постачальниками схожих послуг для зберігання. Методом для запобігання є розвиток унікальної функціональності та акцій для залучення користувачів.
Варто мати на увазі вандалізм, оскільки школярі в закладах можуть пошкодити датчики та сканери, які встановлені в закладі. Відповідно, потрібно щоб за пристроями, встановленими на вході в заклад, спостерігали працівники закладу (охоронці).  
Також потрібно пам’ятати про відмова від сканування відбитку пальця. Школярі та працівники мають право на відмову, тому вони будуть мати можливість відмітити присутність через охоронців. 


2.6	Обмеження та винятки


У процесі розробки продукту «EduCheck» існують деякі обмеження та виключення: 
	Використання симулятору: Симулятор арки та сканеру температури реалізовується за допомогою веб-сервісу Wokwi,
	Відсутність додаткового функціоналу: У першому випуску передбачається лише основний функціонал моніторингу та комунікація,
	Залежність від інфраструктури: Наш продукт буде залежати від наявності мережі Інтернет та електропостачання для нормальної роботи системи моніторингу.


2.7 Вимоги до програмної системи та стек технологій


У першому запуску продукту будуть реалізовані лише основні функції для успішної роботи системи, включаючи адміністрування, локалізацію, захист персональних даних. 
Серверна частина (Back-end) повина фиконувати всі функція відповідно до функціоналу решти частин проєкту, а саме: 
	Створення облікових записів для користувачів (відвідувачів та адміністраторів закладу),
	Система авторизації та автентифікації для безпечного доступу до системи(використання jwt-tokens) ,
	Зберігання інформації про відвідування, зміни та запити на сервері,
	Створення запитів на бронювання приміщень або проведення подій, 
	Система для запитів(додавання/редагування/обробка запитів у закладі),
	Комунікація між школярами та викладачами.
Клієнтська частина (Front-end) використовується для адміністрування системи працівниками закладу. Для них існує наступний перелік вимог: 
	Локалізація веб-інтерфейсу,
	Веб-інтерфейс для закладів для моніторингу інформації, обробки та перегляду запитів,
	Веб-інтерфейс для редагування розкладу,
	Відображення аналітичних даних про відвідування та стан школярів.
Мобільний програмний застосунок використвується відвідувачами для роботи з власними даними. Відокремимо наступний мінімум: 
	Локалізація інтерфейсу додатку,
	Перегляд інформації про себе,
	Створення запиту на проведення події або бронювання класу, залу,
	Перегляд розкладу занять та змін до нього,
	Можливість відмітитись самостійно. 
IoT програмний застосунок працює лише з сервером, та відправляє відповідні запити до нього:
	Отримання сигналу про вхід/вихід особи,
	Сканування відбитку пальця,
	Сканування температури тіла,
	Відправка даних про відвідування.
Програмна система складається з серверної частини на мові C# (платформа .NET Core 8, ASP.NET Core, REST API). В якості бази даних використовується SQL Server, СУБД - MS SSMS. Веб-клієнт виконаний за допомогою Angular Framework. Мобільний застосунок використовує 20 технологію .NET MAUI. Для IoT планується використовувати симулятор Wokwi. 
Даний стек технологій підходить для різних операційний систем, тому сервісом можна буде користуватися на будь-яких пристроях.


3	АРХІТЕКТУРА Й ПРОЄКТУВАННЯ СИСТЕМИ
3.1	UML-моделювання


Для моделювання поведінки системи та її окремих частин було використано мову UML. На сьогодні мова UML досі залишається стандартною й однією з найкращих нотацій для розробників, а також менеджерів проектів, власників компаній, підприємців і фахівців із різних галузей [2].  
Було змодельовано діаграму прецедентів (див. Додаток А). На діаграмі виділено 4 «актори» – директора (виконує роль адміністротора для своєї школи), вчителя (робота з учнями свого класу та приміщеннями школи), охоронця (додавання присутності) та учня (пропонує нові пропозиції та відвідує заклад).
Далі було змодельовано діаграму розгортання для розуміння того, як фізичні компоненти розташовані та працюють один з одним (Додаток Б).


3.2	Проєктування бази даних


База даних містить 11 сутностей: Аккаунт, Користувач, Роль, Учень, Вчитель, Школа, Клас, Приміщення, Відвідування, Запит, Відповідь. Сутності пов’язані між собою зв’язками один-до-багатьох та один-до-одного. 
Для створення бази даних було обрано метод Code First – всі таблиці були створені за моделями, описаними у програмному коді згідно ER-діаграму (див. Додаток В), яка була створена спочатку.


3.3	Загальна архітектура програмної системи 


Розроблена програмна система мітить дві складові: серверний застосунок та IoT-застосунок. Робота системи базується на постійному зверненні IoT-прострою до серверної частини, таким чином зменшується навантаження на серверну частину клієнту, оскільки ІоТ-пристрій робить запит лише у разі потреби. 
Кожна частина використовує різні технології та розгортається в різному середовищі. Компоненти взаємодіють між собою через протоколи HTTP. Серверна частина проєкту є основою системи, в її сервісах обробляються всі основні операції за бізнес-логікою, операції маніпуляцій з даними системи, аутентифікація та авторизація. Запит від IoT-пристрою надсилається за допомогою HTTP протоколу.
Перевагами такої архітектури є модульність, яка дозволяє легше масштабувати та розширювати систему, стандартизована взаємодія між компонентами завдяки HTTP для спрощення інтеграції та підтримки системи в подальшому, гнучкість у розробці, оскільки частини системи можуть розроблюватися, підтримуватися та тестуватися окремо, та безпека компонентів системи завдяки авторизації та аутентифікації на серверному рівні.
     

3.4	Архітектура серверної частини


Для створення проєкту було обрано трьох-рівневу архітектуру, що включає рівні доступа до даних, бізнес-логіки та презентаційний рівень. 
Рівень DAL містить інформацію про моделі бази даних та логіку отримання даних з використанням патерну репозиторій. 
Рівень BLL містить інформацію про DTO-моделі, валідацію, сервіси та бізнес-логіку. 
Рівень API містить контролери, які звертаються до сервісів для отримання готових відповідей. 
Система розроблена відповідно до архітектурного стилю клієнт-сервер та використовує принципи REST API для реалізації віддаленого інтерфейсу. Для деталізації роботи між частинами серверного застосунку було створено діаграму пакетів (див. Додаток Г).


3.5	Архітектура ІоТ


Для розробки сканеру відбитку пальців з датчиком температури було обрано технологію Arduino. Для симуляції роботи пристрою було обрано веб сервіс Wokwi. 
Arduino зазвичай використовується для створення малих, потужних мікроконтролерів, і його можна використовувати для розгортання та запуску вбудованих систем. Операційною системою для Arduino є власне програмне середовище Arduino IDE. 
Програмне забезпечення складається з однієї частини, а саме формування даних та відправка їх до серверної частини. Дані формуються у JSON-файл та повертаються до серверної частини. 
Пристрій сканує відбиток пальця та температуру тіла. Для цього створено методи scanFingerprint() та readTemperature() відповідно. 
Оскільки проєкт базований на Arduino, то він має два ключових методи. Метод setup(), який виконується при запуску пристрою та встановлює з’єднання з Інтернет мережею. Мeтод loop() виконується постійно, для считування даних та відправки даних до серверної частини проєкту.

4	ОПИС ПРОГРАМНИХ РІШЕНЬ
4.1	Програмні рішення серверного застосунку
4.1.1	 Робота з базою даних


Для роботи з базою даних було обрано СУБД MS SSMS, яка використовує реляційну базу даних MS Sql Server. Ця база даних добре поєднується з C# та може бути легко розгорнута у сервісі Azure. 
Для роботи з базою даних було обрано ORM фреймворк Entity Framework Core, так як він має підтримку для більш широкого спектру баз даних та може працювати як на Windows, так і на Linux або macOS. Основна логіка роботи з базою даних було описана у класі GenericRepository (див. Додаток Д). 
В коді міграції було додано автоматичний скрипт для додавання базових ролей(учень, вчитель, директор, охоронець, працівник) та надано відповідні права.


4.1.2	 Автентифікація


Для реалізації авторизації та автентифікації використовується JSON Web Token (JWT) (див. Додаток Е). В appseting.json додається інформація про ключ, який використовується в класі JwtService: 
01   private readonly SymmetricSecurityKey _key;
02   public JwtService(IConfiguration config)
03   {
04       _key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(config["TokenKey"]));
05   }
06   public string CreateToken(Account data)
07   {
08       var claims = new List<Claim>
09       {
10          new Claim(JwtRegisteredClaimNames.NameId, data.Login)
11      };
12  
13      var creds = new SigningCredentials(_key, SecurityAlgorithms.HmacSha512Signature);
14  
15      var token = new JwtSecurityToken(
16              claims: claims,
17              expires: DateTime.Now.AddDays(7),
18              signingCredentials: creds
19          );
20  
21      var jwt = new JwtSecurityTokenHandler().WriteToken(token);
22  
23      return jwt;
24  }


4.1.3	 Специфікація REST APІ


Серверна частина реалізована за принципами REST API, оскільки даних підхід спрямований на створення ефективного та масштабованого інтерфейсу для взаємодії з клієнтами. Під принципами REST API у контексті роботи з даними мається на увазі відповідність кожного методу HTTP певній дії. Наприклад, для моєї системи це метод POST для створення, PUT для оновлення, DELETE для видалення та GET для отримання запису (див. додаток Ж).
Контролери Web API ASP.NET унаслідують базовий контролем BaseController, таким чином можна легко реалізувати базовий функціонал для будь-якої моделі бази даних. 


4.1.4	Валідація на сервері


Валідація даних реалізовано за допомогою атрибутів Entity Framework Core та ручною перевіркою даних. Наприклад, для перевірки даних при створені аккаунту використовуються атрибути для DTO-моделей, такі як Required та MinLength. 
1 [Required(ErrorMessage = "Login is required")] 
2 [MinLength(5, ErrorMessage = "Login must be at least 5 characters long")] 
3 public string Login { get; set; } 
4 [Required(ErrorMessage = "Password is required")] 
5 [MinLength(6, ErrorMessage = "Password must be at least 6 characters long")] 6 public string Password { get; set; }


4.1.5	 Локалізація


Серверна частина локалізації пов’язана з коректною обробкою часу. З боку серверу робота з часом відбувається лише під час заповнення даних, під час відмітки відвідування, якщо запит не містить інформації про час, тобто null. 
Інформація про помилки відображається англійською мовою, оскільки англійська – світова мова та дана інформація потрібна лише під час розробки клієнтської частини. 
Для збереження даних про температуру тіла було обрану одиницю вимірювання Цельсію. За потреби дані можуть бути конвертовані на стороні клієнта у інша шкалу за формулою


4.1.6	 Використання механізму Dependency Injection


Для передачі залежностей використано механізм Dependency Injection. Приклад реалізації: 
1 services.AddSingleton<IJwtService, JwtService>(); 
2 services.AddScoped<IUserService, UserService>();
У зазначеному вище коді наведено два підходи. При використанні AddSingleton створюється один екземпляр сервісу який використовується протягом усього життєвого циклу додатка. При використанні AddScoped створюється новий екземпляр сервісу для кожного HTTP-запиту, який після виконання запиту видаляється. 
Це дозволяє легко змінити залежності в разі потреби, налаштовувати час життя залежності та облегшувати тестування й розуміння коду.


4.1.7	 Забезпечення безпеки даних


Забезпечення безпеки даних у серверному застосунку включає: 
	хешування користувацьких паролів, збереження цих даних в базі даних у зашифрованому вигляді; 
	використання ORM фреймворку Entity Framework, який запобігає SQL ін'єкції; 
	упроваджені аутентифікація і авторизація користувачів за токеном JWT (JSON Web Token). 
Права доступу користувачів передаються до клієнтської частини застосунку, де вже буде надаватися лише відповідний функціонал. Кожен користувач має доступ лише до необхідної для його роботи інформації.


4.2	Програмні рішення ІоТ-застосунку
4.2.1	 Формування запитів


Програмне забезпечення для сканування відвідування є повнозначною частиною складної системи. 
Застосунок самостійно считує дані та відправляє їх до серверу. 
Серверній частині пристрій надсилає сформовані запити про відвідування. Тіло запиту містить скан відбитку пальця, температуру тіла та час. 
URI серверної частини містить в програмному коді як змінна. Обмін інформацією реалізовано за допомогою HttpClient, який приймає базову адресу сервера: 
1. HTTPClient http; 
2. http.begin(serverUrl.c_str()); 
3. http.addHeader("Content-Type", "application/json"); 
4. String json = "{\"fingerprint\":" + fingerprint + "\"time\":" + timeString + ",\"temperature\":" + temperature + "}"; 
5. int httpResponseCode = http.POST(json)


4.2.2	 Локалізація


Програмне забезпечення не виводить інформацію для клієнта, а лише відправляє запит до серверної частини. 
Час відвідування було локалізовано. А саме для отримання поточного часу використовується метод getLocalTime(). Після чого час конвертується у формат "%Y-%m-%dT%H:%M:%S.000Z" відповідно до типу змінної, яку очікує серверна частина.


4.2.3 Обчислення статистики


Оскільки система не містить дані про попередні відвідування, то ми не можемо сформувати статистику. Для цього є певні методи серверної частини для обрахунку середніх, максимальних та мінімальних показників відвідування.


4.2.4 Адміністрування пристрою


Налаштування програмного забезпечення, а саме встановлення даних інтернет мережі та URL серверної частини, відбувається в програмному коді (див. Додаток К).


ВИСНОВКИ


У результаті виконання курсового проєкту з дисципліни було покращено навички зі створення складних програмних систем у процесі проєктування та імплементації програмної системи  для збору інформації про діяльність школярів та працівників навчального закладу з використанням сканерів відбитку пальця та температури.
Спроєктована система є платформою для навчальних закладів, де кожен користувач системи може переглядати стан залів, історію своїх відвідувань та пропонувати нові пропозиції та ідеї. 
Розроблена система складається з серверного застосунку, та ІоТ-пристрою з використанням основних принципів проєктування архітектури програмного забезпечення.
При розробці проєкту використовувався один з варіантів архітектур програмного забезпечення, патерни проєктування [3], принципи «чистого» коду [4]; виконано аналіз предметної області, галузі застосування та впровадження програмного рішення; проєктування системи та бази даних. Програмну реалізацію задуму було виконано з дотриманням принципів «чистого» коду [3, 4] та «чистої» архітектури [4]. Результати проєктування та розробки викладено у пояснювальній записці до курсового проєкту.
Для демонстрації роботи програмної системи було проведено функціональне тестування [5] основних заявлених сценаріїв її використання. 
Програмний код системи розміщено в публічному репозиторії в системі контролю версій за рекомендованим посиланням [6].


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	Офіційна сторінка Ajax Systems URL: https://ajax.systems/ua/ (дата звернення 10.05.2024р.) 
2.	Microsoft 365 Team // Простий посібник зі схем UML і моделювання баз даних // вересня 24, 2019. URL: https://www.microsoft.com/uk-ua/microsoft-365/business-insights-ideas/resources/guide-to-uml-diagramming-and-database-modeling (дата звернення 10.05.2024р.)
3.	Мартін Р. Чистий код. Створення і рефакторинг за допомогою Agile : 2-ге вид. Харків : Фабула, 2019. 448 с.
4.	Мартін Р. Чиста архітектура. Харків : Фабула, 2019. 368 с.
5.	Демо функціонального тестування Програмної системи для автоматизації логістики інтернет-шопінгу. URL: https://youtu.be/EtfSLHNESAM (дата звернення: 16.06.2024).
6.	Програмний код розробленої системи. URL: https://github.com/NureFomychovArtem/apzkr-pzpi-21-3-fomychov-artem (дата звернення: 16.06.2024).


ДОДАТОК А
UML-діаграма прецедентів


Рисунок А.1 – UML діаграма прецедентів для розробленої серверної частини системи «EduCheck»


Рисунок А.2 – UML діаграма прецедентів для розробленого IoT-застосунку системи «EduCheck»


ДОДАТОК Б
UML-діаграма розгортання


Рисунок Б.1 – UML діаграма розгортання


ДОДАТОК В
ER-діаграма

 
Рисунок В.1 – ER-діаграма для створення бази даних системи


ДОДАТОК Г
UML-діаграма пакетів

 
Рисунок Г.1 – UML-діаграма пакетів серверного частини проєкту


Рисунок Г.2 – UML-діаграма пакетів IoT-застосунку


Додаток Д
Код GenericRepository


1   using DAL.Data;
2   using DAL.Repository.Interfaces;
3   using Microsoft.EntityFrameworkCore;
4   using System.Linq.Expressions;
5   
6   namespace DAL.Repository
7   {
8       public class GenericRepository<TEntity> : IGenericRepository<TEntity> where TEntity : class
9       {
10          protected readonly DBContext _dbContext;
11          protected readonly DbSet<TEntity> _dbSet;
12  
13          protected GenericRepository(
14          DBContext context)
15          {
16              _dbContext = context;
17              _dbSet = context.Set<TEntity>();
18          }
19          public async Task<IEnumerable<TEntity>> GetAllAsync()
20          {
21              return await _dbSet.ToListAsync();
22          }
23          public async Task<TEntity> GetByIdAsync(int id)
24          {
25              return await _dbSet.FindAsync(id);
26          }
27          public async Task CreateAsync(TEntity entity)
28          {
29              await _dbSet.AddAsync(entity);
30              _dbContext.SaveChanges();
31          }
32  
33          public void Delete(TEntity entity)
34          {
35              _dbSet.Remove(entity);
36              _dbContext.SaveChanges();
37          }
38  
39          public void Update(TEntity entity)
40          {
41              _dbSet.Update(entity);
42              _dbContext.SaveChanges();
43          }
44          public async Task LoadRelatedDataAsync<TEntity>(TEntity entity, Expression<Func<TEntity, object>> include)
45          {
46              if (entity == null || include == null)
47                  return;
48  
49              var propertyName = (include.Body as MemberExpression)?.Member.Name;
50              if (string.IsNullOrEmpty(propertyName))
51                  throw new ArgumentException("Invalid member access expression", nameof(include));
52  
53              await _dbContext.Entry(entity).Reference(propertyName).LoadAsync();
54          }
55      }
56  }


Додаток Е
Код AccountService


1   using AutoMapper;
2   using BLL.DTO;
3   using BLL.Service.Interfaces;
4   using DAL.Data;
5   using DAL.Entities;
6   using DAL.Repository.Interfaces;
7   using System.Security.Cryptography;
8   using System.Text;
9   
10  namespace BLL.Service
11  {
12      public class AccountService : IAccountService
13      {
14          private readonly DBContext _dbContext;
15          private readonly IJwtService _jwtService;
16          private readonly IAccountRepository _accountRepository;
17          private readonly IUserRepository _userRepository;
18          private readonly IMapper _mapper;
19  
20          public AccountService(
21              DBContext dbContext,
22              IAccountRepository accountRepository,
23              IUserRepository userRepository,
24              IJwtService jwtService,
25              IMapper mapper)
26          {
27              _dbContext = dbContext;
28              _accountRepository = accountRepository;
29              _userRepository = userRepository;
30              _jwtService = jwtService;
31              _mapper = mapper;
32          }
33  
34          /// <summary>
35          /// Отримати список аккаунтів
36          /// </summary>
37          public async Task<IEnumerable<AccountDTO>> GetAllAsync()
38          {
39              var accounts = await _accountRepository.GetAllAsync();
40              var users = await _userRepository.GetAllAsync();
41  
42              var result = _mapper.Map<IEnumerable<AccountDTO>>(accounts);
43  
44              foreach (var account in result)
45              {
46                  account.User = _mapper.Map<UserDTO>(users.SingleOrDefault(x => x.AccountId == account.Id));
47              }
48  
49              return result;
50          }
51  
52          /// <summary>
53          /// Отримати заклад за його ID
54          /// </summary>
55          public async Task<AccountDTO> GetByIdAsync(int id)
56          {
57              if (id <= 0)
58              {
59                  throw new Exception("Incorrect Id");
60              }
61  
62              var account = await _accountRepository.GetByIdAsync(id)
63                  ?? throw new Exception("Object was not found");
64  
65              return _mapper.Map<AccountDTO>(account);
66          }
67  
68          /// <summary>
69          /// Вхід користувача
70          /// </summary>
71          public async Task<AccountDTO> LoginAsync(LoginAccountDTO data)
72          {
73              var account = (await _accountRepository.GetAllAsync()).FirstOrDefault(x => x.Login == data.Login)
74                  ?? throw new Exception("Login is incorrect");
75  
76              using var hmac = new HMACSHA512(account.PasswordSalt);
77              var computedHash = hmac.ComputeHash(Encoding.UTF8.GetBytes(data.Password));
78  
79              for (int i = 0; i < computedHash.Length; i++)
80              {
81                  if (computedHash[i] != account.PasswordHash[i])
82                      throw new Exception("Password is incorrect");
83              }
84  
85              var accountDto = _mapper.Map<AccountDTO>(account);
86              accountDto.Token = _jwtService.CreateToken(account);
87              accountDto.User = _mapper.Map<UserDTO>((await _userRepository.GetAllAsync()).SingleOrDefault(x => x.AccountId == account.Id));
88              return accountDto;
89          }
90          /// <summary>
91          /// Створити новий аккаунт
92          /// </summary>
93          public async Task<AccountDTO> CreateAsync(CreateAccountDTO data)
94          {
95              if (string.IsNullOrWhiteSpace(data.Login))
96              {
97                  throw new Exception("Login is null!");
98              }
99              if (string.IsNullOrWhiteSpace(data.Password))
100             {
101                 throw new Exception("Password is null!");
102             }
103 
104             var check = await _accountRepository.GetAllAsync();
105 
106             if (check.Where(x => x.Login == data.Login).Any())
107             {
108                 throw new Exception("Object already exist!");
109             }
110             using var hmac = new HMACSHA512();
111 
112             var account = new Account
113             {
114                 Login = data.Login,
115                 PasswordHash = hmac.ComputeHash(Encoding.UTF8.GetBytes(data.Password)),
116                 PasswordSalt = hmac.Key
117             };
118 
119             await _accountRepository.CreateAsync(account);
120 
121             var accountDto = _mapper.Map<AccountDTO>(account);
122             accountDto.Token = _jwtService.CreateToken(account);
123 
124             return accountDto;
125         }
126 
127         /// <summary>
128         /// Оновити заклад
129         /// </summary>
130         public async Task UpdateAsync(int id, UpdateAccountDTO data)
131         {
132             if (id <= 0)
133             {
134                 throw new Exception("Incorrect Id");
135             }
136 
137             var account = await _accountRepository.GetByIdAsync(id);
138 
139             if (account == null)
140             {
141                 throw new Exception("Object was not found");
142             }
143 
144             if (!string.IsNullOrWhiteSpace(data.Password))
145             {
146                 using var hmac = new HMACSHA512();
147 
148                 account.PasswordHash = hmac.ComputeHash(Encoding.UTF8.GetBytes(data.Password));
149                 account.PasswordSalt = hmac.Key;
150             }
151 
152             _accountRepository.Update(account);
153         }
154 
155         /// <summary>
156         /// Видалити заклад
157         /// </summary>
158         public async Task DeleteAsync(int id)
159         {
160             if (id <= 0)
161             {
162                 throw new Exception("Incorrect Id");//Неправильний id
163             }
164 
165             var account = await _accountRepository.GetByIdAsync(id);
166 
167             if (account == null)
168             {
169                 throw new Exception("Object was not found");//Об'єкт не знайдено
170             }
171 
172             _accountRepository.Delete(account);
173         }
174     }
175 }


Додаток Ж
Специфікація REST API


Посилання	Метод	Призначення
/api/Account/all	GET	Отримання всіх аккаунтів
/api/Account/{id}	GET	Отримання аккаунту за ID
/api/Account/LoginUser	POST	Аутентифікація користувача
/api/User/all/	GET	Отримання всіх користувачів
/api/User/{id}	GET	Отримання користувача за ID
/api/User/{id}	PUT	Оновлення користувача за ID
/api/User/{id}	DELETE	Видалення користувача за ID
/api/User	POST	Додавання користувача
/api/School/all	GET	Отримання всіх шкіл
/api/School/{id}	GET	Отримання школи за ID
/api/School/{id}	PUT	Оновлення школи за ID
/api/School/{id}	DELETE	Видалення школи за ID
/api/School	POST	Додавання школи
/api/Classroom/all	GET	Отримання всіх приміщень
/api/Classroom/{id}	GET	Отримання класу за ID
/api/Classroom/{id}	PUT	Оновлення класу за ID
/api/Classroom/{id}	DELETE	Видалення класу за ID
/api/Classroom	POST	Додавання класу
/api/Class/all	GET	Отримання всіх класів
/api/Class/{id}	GET	Отримання класу за його ID
/api/Class/StudentId/{id}	GET	Отримання класу за ID учня
/api/Class/{id}	PUT	Оновлення класу за ID
/api/Class/{id}	DELETE	Видалення класу за ID
/api/Class	POST	Додавання класу
/api/Student/all	GET	Отримання всіх студентів
/api/Student/{id}	GET	Отримання учня за його ID
/api/Student/class/{id}	GET	Отримання учнів класу
/api/Student	POST	Додавання учня
/api/Student/{id}	PUT	Оновлення учня за ID
/api/Student/{id}	DELETE	Видалення учня за ID
/api/Teacher/all	POST	Отримання всіх вчителів
/api/Teacher/{id}	GET	Отримання вчителя за ID
/api/Teacher/class/{id}	GET	Отримання класів вчителя
/api/Teacher/{id}	PUT	Оновлення вчителя за ID
/api/Teacher/{id}	DELETE	Видалення вчителя за ID
/api/Teacher	POST	Додавання вчителя
/api/Request/all	GET	Отримання всіх запитів
/api/Request/{id}	GET	Отримання запиту за ID
/api/Request/{id}	PUT	Оновлення запиту за ID
/api/Request/{id}	DELETE	Видалення запиту за ID
/api/Request	POST	Додавання запиту
/api/Answer/all	GET	Отримання всіх відповідей
/api/Answer/{id}	GET	Отримання відповіді за ID
/api/Answer/{id}	PUT	Оновлення відповіді за ID
/api/Answer/{id}	DELETE	Видалення відповіді за ID
/api/Answer	POST	Додавання відповіді
/api/Attendance/all	GET	Отримання всіх відвідувань
/api/Attendance/{id}	GET	Отримання відвідування за ID
/api/Attendance/{id}	GET	Отримання відвідувань користувача
/api/Attendance/{id}	GET	Отримання статистики відвідувань користувача
/api/Attendance/{id}	PUT	Оновлення відвідування за ID
/api/Attendance/{id}	DELETE	Видалення відвідування за ID
api/Attendance	POST	Додавання відвідування


Додаток К
Код IoT-застосунку


1   #include <WiFi.h>
2   #include <time.h>
3   #include <HTTPClient.h>
4   #include <Adafruit_ILI9341.h>
5   #include <ArduinoJson.h>
6   
7   //Значення Wi-Fi-мережі для отримання доступу
8   #define WIFI_SSID "Wokwi-GUEST"
9   #define WIFI_PASSWORD ""
10  #define WIFI_CHANNEL 6
11  
12  String serverUrl = "https://localhost:44320/api/Attendance";
13  DynamicJsonDocument doc(1024);
14  String fingerprint = "";
15  
16  #define tft_cs 15
17  #define tft_dc 2
18  #define tft_mosi 23
19  #define tft_sclk 18
20  
21  Adafruit_ILI9341 tft = Adafruit_ILI9341(tft_cs, tft_dc);
22  
23  #define WIDTH 320
24  #define HEIGHT 240
25  
26  #define THERMISTOR_PIN 14
27  float temperature;
28  
29  void setup(void) {
30    Serial.begin(115200);
31  
32    // Підключення до мережі Wi-Fi
33    Serial.print("Connecting to a WiFi network");
34    WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL);
35    while (WiFi.status() != WL_CONNECTED) {
36      delay(100);
37      Serial.print(".");
38    }
39    Serial.println(" Connected!");
40    Serial.println("IP: " + WiFi.localIP().toString());
41  
42    configTime(0, 0, "pool.ntp.org");
43    while (!time(nullptr)) {
44      delay(1000);
45      Serial.println("Waiting for time synchronization...");
46    }
47  
48    tft.begin();
49    tft.setRotation(1);
50  }
51  
52  void loop() {
53    fingerprint = scanFingerprint();
54    Serial.print("Fingerprint: ");
55    Serial.println(fingerprint);
56  
57    temperature = readTemperature();
58    Serial.print("Temperature: ");
59    Serial.println(temperature);
60  
61    struct tm timeinfo;
62    if (!getLocalTime(&timeinfo)) {
63      Serial.println("Failed to obtain time");
64    }
65    const int bufferSize = 50;
66    char buffer[bufferSize];
67  
68    // Форматування часу за допомогою strftime()
69    strftime(buffer, bufferSize, "%Y-%m-%dT%H:%M:%S.000Z", &timeinfo);
70  
71    // Конвертуємо рядок char в String
72    String timeString = String(buffer);
73  
74    Serial.print("Time: ");
75    Serial.println(timeString);
76  
77    HTTPClient http;
78    http.begin(serverUrl.c_str());
79    http.addHeader("Content-Type", "application/json");
80  
81    String json = "{\"fingerprint\":" + fingerprint + "\"time\":" + timeString + ",\"temperature\":" + temperature + "}";
82    int httpResponseCode = http.POST(json);
83    Serial.println(httpResponseCode);
84  
85    if (httpResponseCode > 0) {
86      String response = http.getString();
87      Serial.println(response);
88      } else {
89        Serial.println("Failed to update data");
90      }
91  
92    http.end();
93    delay(1000);
94  }
95  
96  float readTemperature() {
97    int rawValue = analogRead(THERMISTOR_PIN);
98  
99    float temperature = map(rawValue, 0, 4095, 36.6, 50);
100 
101   return temperature;
102 }
103 
104 String scanFingerprint() {
105   String result = "";
106   for (int y = 0; y < HEIGHT; y++) {
107     for (int x = 0; x < WIDTH; x++) {
108       tft.drawPixel(x, y, x * y);
109       result += (x + y);
110     }
111   }
112 
113   return result;
114 }
